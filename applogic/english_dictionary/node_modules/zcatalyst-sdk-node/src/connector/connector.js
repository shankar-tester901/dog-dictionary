'use strict';

const CatalystAppInternals = require('../catalyst-app').CatalystAppInternals;
const CatalystConnectorError = require('../utils/error').CatalystConnectorError;

const validator = require('../utils/validator');
const constants = require('../utils/constants');

class Connector extends CatalystAppInternals {
	constructor(connectorDetails, connectionInstance) {
		super(connectionInstance);

		this.connectorName = connectorDetails[constants.CONNECTOR_NAME];
		this.authUrl = connectorDetails[constants.AUTH_URL];
		this.refreshUrl = connectorDetails[constants.REFRESH_URL];
		this.refreshToken = connectorDetails[constants.REFRESH_TOKEN];
		this.clientId = connectorDetails[constants.CLIENT_ID];
		this.clientSecret = connectorDetails[constants.CLIENT_SECRET];
		this.expiresIn = connectorDetails[constants.EXPIRES_IN];
		this.redirectUrl = connectorDetails[constants.REDIRECT_URL];

		this.accessToken = null;

		this.app = connectionInstance.app;
		this.requester = connectionInstance.requester;
	}

	getAccessToken() {
		return this.app
			.cache()
			.segment()
			.get(this._connectorName)
			.then((cachedTokenObj) => {
				let value = cachedTokenObj.cache_value;
				if (value === null) {
					return this.refreshAndPersistToken();
				}

				let remainingTime = cachedTokenObj.ttl_in_milliseconds;
				let actualTime = 3600000;
				let time = actualTime - remainingTime;

				if (time > this.expiresIn * 1000) {
					return this.refreshAndPersistToken();
				}
				return value;
			});
	}

	generateAccessToken(code) {
		return validator
			.wrapValidatorsWithPromise(() => {
				validator.isNonEmptyString(code, 'grant_token', true);
				validator.isNonEmptyString(code, constants.REDIRECT_URL, true);
			}, CatalystConnectorError)
			.then(() => {
				const request = {
					method: 'POST',
					url: this.authUrl,
					data: {
						[constants.GRANT_TYPE]: 'authorization_code',
						[constants.CODE]: code,
						[constants.CLIENT_ID]: this.clientId,
						[constants.CLIENT_SECRET]: this.clientSecret,
						[constants.REDIRECT_URL]: this.redirectUrl
					}
				};
				return this.requester.send(request);
			})
			.then((resp) => {
				let tokenObj = resp.data;
				return validator
					.wrapValidatorsWithPromise(() => {
						validator.isNonNullObject(tokenObj, 'auth_response', true);
						validator.validateObject(
							tokenObj,
							[constants.ACCESS_TOKEN, constants.REFRESH_TOKEN, constants.EXPIRES_IN],
							'auth_response',
							true
						);
					}, CatalystConnectorError)
					.then(() => tokenObj);
			})
			.then((authResponse) => {
				this.accessToken = authResponse[constants.ACCESS_TOKEN];
				this.refreshToken = authResponse[constants.REFRESH_TOKEN];
				this.expiresIn = authResponse[constants.EXPIRES_IN];
				return this.putAccessTokenInCache();
			})
			.then(() => {
				return this.accessToken;
			});
	}

	refreshAndPersistToken() {
		return this.refreshAccessToken()
			.then(() => {
				return this.putAccessTokenInCache();
			})
			.then(() => {
				return this.accessToken;
			});
	}

	refreshAccessToken() {
		return validator
			.wrapValidatorsWithPromise(() => {
				validator.isNonEmptyString(this.refreshToken, 'refresh_token', true);
				validator.isNonEmptyString(this.refreshUrl, 'refresh_url', true);
			}, CatalystConnectorError)
			.then(() => {
				const request = {
					method: 'POST',
					url: this.refreshUrl,
					data: {
						[constants.GRANT_TYPE]: 'refresh_token',
						[constants.CLIENT_ID]: this.clientId,
						[constants.CLIENT_SECRET]: this.clientSecret,
						[constants.REFRESH_TOKEN]: this.refreshToken
					}
				};
				return this.requester.send(request);
			})
			.then((resp) => {
				let tokenObject = resp.data;
				return validator
					.wrapValidatorsWithPromise(() => {
						validator.isNonNullObject(tokenObject, 'auth_response', true);
						validator.validateObject(
							tokenObject,
							[constants.ACCESS_TOKEN, constants.EXPIRES_IN],
							'auth_response',
							true
						);
					}, CatalystConnectorError)
					.then(() => tokenObject);
			})
			.then((authResponse) => {
				this.accessToken = authResponse[constants.ACCESS_TOKEN];
				this.expiresIn = authResponse[constants.EXPIRES_IN];
			});
	}

	putAccessTokenInCache() {
		return this.app
			.cache()
			.segment()
			.put(this._connectorName, this.accessToken, 1);
	}

	get _connectorName() {
		return 'ZC_CONN_' + this.connectorName;
	}
}

exports.Connector = Connector;
