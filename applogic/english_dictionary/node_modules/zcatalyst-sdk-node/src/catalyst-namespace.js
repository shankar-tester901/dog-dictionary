'use strict';

const readFileSync = require('fs').readFileSync;

const credential = require('./auth/credential');
const CatalystAppError = require('./utils/error').CatalystAppError;
const CatalystApp = require('./catalyst-app').CatalystApp;
const isNonEmpty = require('./utils/validator').isNonEmpty;
const isNonNullObject = require('./utils/validator').isNonNullObject;
const isStringOrNumber = require('./utils/validator').isStringOrNumber;
const isNonEmptyString = require('./utils/validator').isNonEmptyString;
const constants = require('./utils/constants');

const catalystCredential = {
	refreshToken: (refreshTokenObj) => {
		return new credential.RefreshTokenCredential(refreshTokenObj);
	},
	accessToken: (access_token) => {
		return new credential.AccessTokenCredential({ access_token });
	},
	ticket: (ticket) => {
		return new credential.TicketCredential({ ticket });
	}
};

class CatalystNamespace {
	constructor() {
		this.credential = catalystCredential;
		this.user = constants.CREDENTIAL_USER;
		this.type = constants.INIT_TYPE;
		this.project = {};
	}

	initializeApp(options, projectName) {
		if (typeof projectName === 'undefined') {
			projectName = constants.DEFAULT_APP_NAME;
		}
		if (projectName in this.project) {
			throw new CatalystAppError('duplicate_app', 'The app already exists.');
		}

		if (!isNonNullObject(options)) {
			options = this.loadOptionsFromEnvVar();
			if (!isNonEmpty(options)) {
				throw new CatalystAppError(
					'invalid_app_options',
					'Options provided for initializeApp in invalid.'
				);
			}
		}

		// credential alone can be not given
		if (typeof options.credential === 'undefined') {
			options.credential = new credential.ApplicationDefaultCredential();
		}
		try {
			isStringOrNumber(options.project_id, 'project_id in options', true);
			isStringOrNumber(options.project_key, 'project_key in options', true);
			isNonEmptyString(projectName, 'projectName', true);
		} catch (e) {
			throw new CatalystAppError(e.code, e.message);
		}

		const app = new CatalystApp(options);
		this.project[projectName] = app;
		return app;
	}

	initialize(object, { defaultUser = constants.CREDENTIAL_USER.user, type } = {}) {
		let appOptions = {};
		switch (type) {
			case constants.INIT_TYPE.applogic:
				if (!object || typeof object.headers !== 'object') {
					throw new CatalystAppError(
						'invalid_app_object',
						'the object passed to initialize method is not valid'
					);
				}
				appOptions = this.loadOptionsFromObj(object, 'headers');
				appOptions.credential = new credential.ObjectCredential(
					object,
					'headers',
					defaultUser
				);
				break;
			case constants.INIT_TYPE.basicio:
				if (!object || typeof object.catalystHeaders !== 'object') {
					throw new CatalystAppError(
						'invalid_app_object',
						'the object passed to initialize method is not valid'
					);
				}
				appOptions = this.loadOptionsFromObj(object, 'catalystHeaders');
				appOptions.credential = new credential.ObjectCredential(
					object,
					'catalystHeaders',
					defaultUser
				);
				break;
			default:
				if (object && typeof object.headers === 'object') {
					return this.initialize(object, {
						defaultUser,
						type: constants.INIT_TYPE.applogic
					});
				}
				if (object && typeof object.catalystHeaders === 'object') {
					return this.initialize(object, {
						defaultUser,
						type: constants.INIT_TYPE.basicio
					});
				}
				throw new CatalystAppError(
					'invalid_app_object',
					'unable to find the type of initialisation. kindly specify one'
				);
		}
		return new CatalystApp(appOptions, type);
	}

	loadOptionsFromObj(obj, key) {
		let project_id = obj[key][constants.PROJECT_HEADER.id];
		let project_key = obj[key][constants.PROJECT_HEADER.key];
		let project_domain = obj[key][constants.PROJECT_HEADER.domain] || 'catalyst.zoho.com';
		if (!project_key || !project_id) {
			throw new CatalystAppError('invalid_project_details', 'Failed to parse object');
		}
		return {
			project_id,
			project_key,
			project_domain
		};
	}

	loadOptionsFromEnvVar() {
		const config = process.env[constants.CATALYST_CONFIG_ENV_KEY];
		if (!isNonEmptyString(config)) {
			return {};
		}
		try {
			const contents = config.startsWith('{') ? config : readFileSync(config, 'utf8');
			return JSON.parse(contents);
		} catch (err) {
			// Throw a nicely formed error message if the file contents cannot be parsed
			throw new CatalystAppError(
				'invalid_app_options',
				'Failed to parse app options : ' + err
			);
		}
	}
	app(projectName) {
		if (typeof projectName === 'undefined') {
			projectName = constants.DEFAULT_APP_NAME;
		}
		if (!isNonEmptyString(projectName)) {
			throw new CatalystAppError(
				'invalid_app_name',
				'Invalid app name provided. App name must be a non-empty string.'
			);
		} else if (!(projectName in this.project)) {
			let errorMessage =
				projectName === constants.DEFAULT_APP_NAME
					? 'The default project does not exist. '
					: `project named "${projectName}" does not exist. `;
			errorMessage += 'Make sure you call initializeApp() before getting the desired app';

			throw new CatalystAppError('no_app', errorMessage);
		}

		return this.project[projectName];
	}
}

module.exports = CatalystNamespace;
