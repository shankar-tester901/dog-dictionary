'use strict';

const isNonNullObject = require('./utils/validator').isNonNullObject;
const isNonEmptyString = require('./utils/validator').isNonEmptyString;
const validateObject = require('./utils/validator').validateObject;
const isValidType = require('./utils/validator').isValidType;
const CatalystAppError = require('./utils/error').CatalystAppError;
const CatalystAuthError = require('./utils/error').CatalystAuthError;
const credential = require('./auth/credential');
const helper = require('./utils/helper');

class CatalystAppInternals {
	constructor(appObj) {
		this.credential = helper.copyInstance(appObj.credential);
		this.projectKey = appObj.projectKey || '';
		this.projectId = appObj.projectId;
	}

	isTicketBasedAuth() {
		return this.credential.isTicketBasedAuth();
	}

	switchUser(user) {
		if (this.credential instanceof credential.ObjectCredential) {
			return this.credential.switchUser(user);
		}
	}

	getToken() {
		const notExpired =
			this.credential.cachedToken &&
			this.credential.cachedToken.expirationTime &&
			(this.credential.cachedToken.expirationTime === -1 ||
				this.credential.cachedToken.expirationTime > Date.now());
		if (this.credential.cachedTokenPromise && notExpired) {
			return this.credential.cachedTokenPromise.catch((error) => {
				if (this.credential.cachedToken) {
					this.credential.cachedTokenPromise = Promise.resolve(
						this.credential.cachedToken
					);
					return this.credential.cachedTokenPromise;
				}
				this.credential.cachedTokenPromise = null;
				throw error;
			});
		} else {
			this.credential.cachedTokenPromise = this.credential.getAccessToken().then((result) => {
				if (!isNonNullObject(result)) {
					throw new CatalystAuthError(
						'invalid_credential',
						'Unknown result while retriving access token.'
					);
				}
				let token;
				if (isNonEmptyString(result.ticket)) {
					token = {
						ticket: result.ticket,
						expirationTime: -1,
						header: 'Zoho-ticket ' + result.ticket
					};
				} else if (isNonEmptyString(result.access_token)) {
					token = {
						accessToken: result.access_token,
						expirationTime: result.expires_in ? Date.now() + result.expires_in : null,
						header: 'Zoho-oauthtoken ' + result.access_token
					};
				} else {
					throw new CatalystAuthError(
						'invalid_credential',
						'access_token could not be generated.'
					);
				}
				this.credential.cachedToken = token;
				return token;
			});
			return this.credential.cachedTokenPromise;
		}
	}
}
exports.CatalystAppInternals = CatalystAppInternals;

class CatalystApp {
	constructor(options, type) {
		this.options = options;
		this.type = type;
		this.services = {};
		this.internal = {};

		try {
			isNonNullObject(this.options, 'options', true);
			validateObject(this.options, ['credential'], 'options', true);
			isNonNullObject(this.options.credential, 'options.credential', true);
			isValidType(
				this.options.credential.getAccessToken,
				'function',
				'options.credential',
				true
			);
		} catch (e) {
			throw new CatalystAppError(e.code, e.message);
		}

		this.internal.projectId = options.project_id;
		this.internal.projectKey = options.project_key;
		this.internal.credential = options.credential;
	}

	cache() {
		return this.ensureService('cache', () => {
			const cacheService = require('./cache/cache').Cache;
			return new cacheService(this);
		});
	}

	queue() {
		return this.ensureService('queue', () => {
			const queueService = require('./queue/queue').Queue;
			return new queueService(this);
		});
	}

	cron() {
		return this.ensureService('cron', () => {
			const cronService = require('./cron/cron').Cron;
			return new cronService(this);
		});
	}

	datastore() {
		return this.ensureService('datastore', () => {
			const dataService = require('./datastore/datastore').Datastore;
			return new dataService(this);
		});
	}

	filestore() {
		return this.ensureService('file', () => {
			const fileService = require('./file/filestore').Filestore;
			return new fileService(this);
		});
	}

	zcql() {
		return this.ensureService('zcql', () => {
			const zcqlService = require('./zcql/zcql').ZCQL;
			return new zcqlService(this);
		});
	}

	email() {
		return this.ensureService('mail', () => {
			const mailService = require('./email/email').Email;
			return new mailService(this);
		});
	}

	search() {
		return this.ensureService('search', () => {
			const searchService = require('./search/search').Search;
			return new searchService(this);
		});
	}

	gql() {
		return this.ensureService('gql', () => {
			const gqlService = require('./gql/gql').GQL;
			return new gqlService(this);
		});
	}

	functions() {
		return this.ensureService('functions', () => {
			const funcService = require('./functions/functions').Functions;
			return new funcService(this);
		});
	}

	userManagement() {
		return this.ensureService('userManagement', () => {
			const authService = require('./user-management/user-management').UserManagement;
			return new authService(this);
		});
	}

	pushNotification() {
		return this.ensureService('pushNotification', () => {
			const pushService = require('./push-notification/push-notification').PushNotification;
			return new pushService(this);
		});
	}

	zia() {
		return this.ensureService('zia', () => {
			const ziaService = require('./zia/zia').Zia;
			return new ziaService(this);
		});
	}

	connection(prop) {
		return this.ensureService('connection', () => {
			const connectorService = require('./connector/connection').Connection;
			return new connectorService(this, prop);
		});
	}

	ensureService(serviceName, initializer) {
		let service;
		if (serviceName in this.services) {
			service = this.services[serviceName];
		} else {
			service = initializer();
			this.services[serviceName] = service;
		}
		return service;
	}
}

exports.CatalystApp = CatalystApp;
