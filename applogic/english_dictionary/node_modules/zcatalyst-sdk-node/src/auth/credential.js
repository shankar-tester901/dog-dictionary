'use strict';

const readFileSync = require('fs').readFileSync;
const resolve = require('path').resolve;
const stringify = require('querystring').stringify;

const HttpClient = require('../utils/api-request').HttpClient;
const CatalystAuthError = require('../utils/error').CatalystAuthError;
const constants = require('../utils/constants');

const CREDENTIAL_PATH = process.env.HOME
	? resolve(resolve(process.env.HOME, '.config'), constants.CREDENTIAL_SUFFIX)
	: resolve('.', constants.CREDENTIAL_SUFFIX);

function copyAttr(to, from, key, alt) {
	const tmp = from[key] || from[alt];
	if (typeof tmp !== 'undefined') {
		to[key] = tmp;
	}
}

/*
 * Tries to load a RefreshToken from a path. If the path is not present, returns null.
 * Throws if data at the path is invalid.
 */
function fromPath(filePath) {
	var jsonString;
	try {
		jsonString = readFileSync(filePath, 'utf8');
	} catch (ignored) {
		// Ignore errors if the file is not present, as this is sometimes an expected condition
		return null;
	}
	try {
		return JSON.parse(jsonString);
	} catch (err) {
		// Throw a nicely formed error message if the file contents cannot be parsed
		throw new CatalystAuthError('invalid_credential', 'Failed to parse token file: ' + err);
	}
}

function fromEnv() {
	var jsonString;
	try {
		jsonString = process.env[constants.CATALYST_AUTH_ENV_KEY];
	} catch (ignored) {
		// Ignore errors if the file is not present, as this is sometimes an expected condition
		return null;
	}
	try {
		return JSON.parse(jsonString);
	} catch (err) {
		// Throw a nicely formed error message if the file contents cannot be parsed
		throw new CatalystAuthError(
			'invalid_credential',
			'Failed to parse refresh token string from env: ' + err
		);
	}
}

function requestAccessToken(client, request) {
	return client.send(request).then((resp) => {
		const json = resp.data;
		if (json.error) {
			let errorMessage = 'Error fetching access token: ' + json.error;
			throw errorMessage;
		} else if (!json.access_token || !json.expires_in) {
			throw `Unexpected response while fetching access token: ${JSON.stringify(json)}`;
		} else {
			return json;
		}
	});
}

class RefreshToken {
	constructor(json) {
		copyAttr(this, json, 'clientId', 'client_id');
		copyAttr(this, json, 'clientSecret', 'client_secret');
		copyAttr(this, json, 'refreshToken', 'refresh_token');
		let errorMessage;
		if (typeof this.refreshToken !== 'string' || !this.refreshToken) {
			errorMessage = 'Refresh token must contain a "refresh_token" property.';
		}
		if (typeof errorMessage !== 'undefined') {
			throw new CatalystAuthError('invalid_credential', errorMessage);
		}
	}
}

class AccessToken {
	constructor(json) {
		copyAttr(this, json, 'accessToken', 'access_token');
		let errorMessage;
		if (typeof this.accessToken !== 'string' || !this.accessToken) {
			errorMessage = 'Access token must contain a "access_token" property.';
		}
		if (typeof errorMessage !== 'undefined') {
			throw new CatalystAuthError('invalid_credential', errorMessage);
		}
	}
}

class Ticket {
	constructor(json) {
		copyAttr(this, json, 'ticket', 'ticket');
		let errorMessage;
		if (typeof this.ticket !== 'string' || !this.ticket) {
			errorMessage = 'Ticket must contain a "ticket" property.';
		}
		if (typeof errorMessage !== 'undefined') {
			throw new CatalystAuthError('invalid_credential', errorMessage);
		}
	}
}

class RefreshTokenCredential {
	constructor(refreshTokenObject) {
		this.refreshToken = new RefreshToken(refreshTokenObject);
		this.httpClient = new HttpClient();
	}
	isTicketBasedAuth() {
		return false;
	}
	getAccessToken() {
		const postData = stringify({
			client_id: this.refreshToken.clientId,
			client_secret: this.refreshToken.clientSecret,
			refresh_token: this.refreshToken.refreshToken,
			grant_type: 'refresh_token'
		});
		const request = {
			method: 'POST',
			origin: constants.ACCOUNTS_ORIGIN,
			path: '/oauth/v2/token',
			data: postData
		};
		return requestAccessToken(this.httpClient, request);
	}
}

class AccessTokenCredential {
	constructor(accessTokenObject) {
		this.accessToken = new AccessToken(accessTokenObject);
	}
	isTicketBasedAuth() {
		return false;
	}
	getAccessToken() {
		var tokenObj = {};
		tokenObj.access_token = this.accessToken.accessToken;
		return Promise.resolve(tokenObj);
	}
}

class TicketCredential {
	constructor(ticketObj) {
		this.ticket = new Ticket(ticketObj);
	}
	isTicketBasedAuth() {
		return true;
	}
	getAccessToken() {
		var tokenObj = {};
		tokenObj.ticket = this.ticket.ticket;
		return Promise.resolve(tokenObj);
	}
}

class ObjectCredential {
	constructor(obj, key, user) {
		this.adminType = obj[key][constants.CREDENTIAL_HEADER.admin_type];
		this.adminToken = obj[key][constants.CREDENTIAL_HEADER.admin_token];
		this.userType = obj[key][constants.CREDENTIAL_HEADER.user_type];
		this.userToken = obj[key][constants.CREDENTIAL_HEADER.user_token];
		if (!this.adminType || !this.adminToken || !this.userType || !this.userToken) {
			throw new CatalystAuthError('invalid_credential', 'Failed to parse request');
		}
		switch (this.adminType) {
			case constants.CREDENTIAL_TYPE.ticket:
				this.adminCred = new TicketCredential({ ticket: this.adminToken });
				break;
			case constants.CREDENTIAL_TYPE.token:
				this.adminCred = new AccessTokenCredential({ access_token: this.adminToken });
				break;
		}
		switch (this.userType) {
			case constants.CREDENTIAL_TYPE.ticket:
				this.userCred = new TicketCredential({ ticket: this.userToken });
				break;
			case constants.CREDENTIAL_TYPE.token:
				this.userCred = new AccessTokenCredential({ access_token: this.userToken });
				break;
		}
		this.user = user;
	}

	isTicketForAdmin() {
		if (this.adminCred instanceof TicketCredential) {
			return true;
		}
		return false;
	}

	isTicketForUser() {
		if (this.userCred instanceof TicketCredential) {
			return true;
		}
		return false;
	}

	isTicketBasedAuth() {
		switch (this.user) {
			case constants.CREDENTIAL_USER.admin:
				return this.isTicketForAdmin();
			case constants.CREDENTIAL_USER.user:
				return this.isTicketForUser();
		}
	}

	getAccessToken() {
		switch (this.user) {
			case constants.CREDENTIAL_USER.admin:
				return this.adminCred.getAccessToken();
			case constants.CREDENTIAL_USER.user:
				return this.userCred.getAccessToken();
		}
	}

	switchUser(user) {
		this.user = user;
	}
}

class ApplicationDefaultCredential {
	constructor() {
		// It is OK to not have this file. If it is present, it must be valid.
		var token = fromPath(CREDENTIAL_PATH);
		if (!token) {
			token = fromEnv();
		}
		this.ticketBased = false;
		if ('refresh_token' in token) {
			this.credential = new RefreshTokenCredential(token);
		} else if ('access_token' in token) {
			this.credential = new AccessTokenCredential(token);
		} else if ('ticket' in token) {
			this.credential = new TicketCredential(token);
			this.ticketBased = true;
		}
		return;
	}
	isTicketBasedAuth() {
		return this.ticketBased;
	}
	getAccessToken() {
		return this.credential.getAccessToken();
	}
}

module.exports = {
	ApplicationDefaultCredential,
	RefreshTokenCredential,
	AccessTokenCredential,
	TicketCredential,
	ObjectCredential
};
