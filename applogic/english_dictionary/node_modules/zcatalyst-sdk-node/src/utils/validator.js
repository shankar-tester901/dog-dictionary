'use strict';

const parse = require('url').parse;
const CatalystAppError = require('./error').CatalystAppError;
const ValidationError = require('./error').CatalystError;
/**
 * Validates that a value is a byte buffer.
 *
 * @param {any} value The value to validate.
 * @return {boolean} Whether the value is byte buffer or not.
 */
function isBuffer(value) {
	return value instanceof Buffer;
}
exports.isBuffer = isBuffer;

/**
 * Validates that a value is an array.
 *
 * @param {any} value The value to validate.
 * @return {boolean} Whether the value is an array or not.
 */
function isArray(value) {
	return Array.isArray(value);
}
exports.isArray = isArray;

/**
 * Validates that a value is a non-empty array.
 *
 * @param {any} value The value to validate.
 * @return {boolean} Whether the value is a non-empty array or not.
 */
function isNonEmptyArray(value) {
	return isArray(value) && value.length !== 0;
}
exports.isNonEmptyArray = isNonEmptyArray;

/**
 * Validates that a value is a boolean.
 *
 * @param {any} value The value to validate.
 * @return {boolean} Whether the value is a boolean or not.
 */
function isBoolean(value) {
	return typeof value === 'boolean';
}
exports.isBoolean = isBoolean;

/**
 * Validates that a value is a number.
 *
 * @param {any} value The value to validate.
 * @return {boolean} Whether the value is a number or not.
 */
function isNumber(value) {
	return typeof value === 'number' && !isNaN(value);
}
exports.isNumber = isNumber;

/**
 * Validates that a value is a string.
 *
 * @param {any} value The value to validate.
 * @return {boolean} Whether the value is a string or not.
 */
function isString(value) {
	return typeof value === 'string';
}
exports.isString = isString;

function isNonEmpty(value) {
	return value !== '';
}
exports.isNonEmpty = isNonEmpty;

/**
 * Validates that a value is a nullable object.
 *
 * @param {any} value The value to validate.
 * @return {boolean} Whether the value is an object or not.
 */
function isObject(value) {
	return typeof value === 'object' && !isArray(value);
}
exports.isObject = isObject;

/**
 * Validates that a string is a valid email.
 *
 * @param {any} email The string to validate.
 * @return {boolean} Whether the string is valid email or not.
 */
function isEmail(email) {
	if (typeof email !== 'string') {
		return false;
	}
	// There must at least one character before the @ symbol and another after.
	const re = /^[^@]+@[^@]+$/;
	return re.test(email);
}
exports.isEmail = isEmail;

/**
 * Validates that a string is a valid web URL.
 *
 * @param {any} urlStr The string to validate.
 * @return {boolean} Whether the string is valid web URL or not.
 */
function isURL(urlStr) {
	if (typeof urlStr !== 'string') {
		return false;
	}
	// Lookup illegal characters.
	const re = /[^a-z0-9-._~:/?#[\]@!$&'()*+,;=]/i;
	if (re.test(urlStr)) {
		return false;
	}
	try {
		const schemeTest = /^(http|https):/;
		const uri = parse(urlStr);
		const scheme = uri.protocol;
		const slashes = uri.slashes;
		const hostname = uri.hostname;
		const pathname = uri.pathname;
		if (!schemeTest.test(scheme) || !slashes) {
			return false;
		}
		// Validate hostname: Can contain letters, numbers, underscore and dashes separated by a dot.
		// Each zone must not start with a hyphen or underscore.
		if (!/^[a-zA-Z0-9]+[w-]*([.]?[a-zA-Z0-9]+[w-]*)*$/.test(hostname)) {
			return false;
		}
		// Allow for pathnames: (/chars+)*/?
		// Where chars can be a combination of: a-z A-Z 0-9 - _ . ~ ! $ & ' ( ) * + , ; = : @ %
		const pathnameRe = /(\/[0-9].*\?|$)/;
		// Validate pathname.
		if (pathname && !pathnameRe.test(pathname)) {
			return false;
		}
		// Allow any query string and hash as long as no invalid character is used.
	} catch (e) {
		return false;
	}
	return true;
}
exports.isURL = isURL;

/**
 * validates an object. Note : Only one level is supported
 * @param {Object} obj Object to be validated
 * @param {Array} properties properties to be tested for presence
 * @param {String} objName name of obj to be used while throwing an error
 * @param {Boolean} throwErr Boolean to determine if error needs to be thrown.
 * @returns {Boolean} validity of the object
 */
function validateObject(obj, properties, objName, throwErr) {
	if (typeof properties != 'undefined') {
		properties.forEach((element) => {
			if (typeof obj[element] === 'undefined') {
				if (throwErr) {
					throw new ValidationError({
						code: 'invalid-argument',
						message: `Value for property ${element} cannot be null or empty in ${objName} json`
					});
				}
				return false;
			}
		});
	}
	return true;
}
exports.validateObject = validateObject;

/**
 * Validates that a value is a non-empty string.
 *
 * @param {any} value The value to validate.
 * @param {String} name The name of the value to use in error.
 * @param {Boolean} throwErr Boolean to determine if error needs to be thrown.
 * @return {boolean} Whether the value is a non-empty string or not.
 */
function isNonNullNumber(value, name, throwErr) {
	if (isNumber(value) && value !== '' && value !== null) {
		return true;
	}
	if (throwErr) {
		throw new ValidationError({
			code: 'invalid-argument',
			message: `Value provided for ${name} is expected to be a valid non-null number.`
		});
	}
	return false;
}
exports.isNonNullNumber = isNonNullNumber;

/**
 * Validates that a value is a non-empty string.
 *
 * @param {any} value The value to validate.
 * @param {String} name The name of the value to use in error.
 * @param {Boolean} throwErr Boolean to determine if error needs to be thrown.
 * @return {boolean} Whether the value is a non-empty string or not.
 */
function isNonEmptyString(value, name, throwErr) {
	if (isString(value) && value !== '') {
		return true;
	}
	if (throwErr) {
		throw new ValidationError({
			code: 'invalid-argument',
			message: `Value provided for ${name} is expected to be a non-empty and non-null string.`
		});
	}
	return false;
}
exports.isNonEmptyString = isNonEmptyString;

/**
 * Validates that a value is a non-null object.
 *
 * @param {any} value The value to validate.
 * @param {String} name The name of the value to use in error.
 * @param {Boolean} throwErr Boolean to determine if error needs to be thrown.
 * @return {boolean} Whether the value is a non-null object or not.
 */
function isNonNullObject(value, name, throwErr) {
	if (isObject(value) && value !== null) {
		return true;
	}
	if (throwErr) {
		throw new ValidationError({
			code: 'invalid-argument',
			message: `Value provided for ${name} is expected to be a non-empty and non-null json object.`
		});
	}
	return false;
}
exports.isNonNullObject = isNonNullObject;

/**
 * Validates that a value is a non-null object.
 *
 * @param {any} value The value to validate.
 * @param {String} name The name of the value to use in error.
 * @param {Boolean} throwErr Boolean to determine if error needs to be thrown.
 * @return {boolean} Whether the value is a non-null object or not.
 */
function isNonNullArray(value, name, throwErr) {
	if (isArray(value) && value !== null) {
		return true;
	}
	if (throwErr) {
		throw new ValidationError({
			code: 'invalid-argument',
			message: `Value provided for ${name} is expected to be a non-empty and non-null Array.`
		});
	}
	return false;
}
exports.isNonNullArray = isNonNullArray;

/**
 * Validates that a value is a non-null string or number.
 *
 * @param {any} value The value to validate.
 * @param {String} name The name of the value to use in error.
 * @param {Boolean} throwErr Boolean to determine if error needs to be thrown.
 * @return {boolean} Whether the value is a non-null object or not.
 */
function isStringOrNumber(value, name, throwErr) {
	if (isNonEmptyString(value) || isNonNullNumber(value)) {
		return true;
	}
	if (throwErr) {
		throw new ValidationError({
			code: 'invalid-argument',
			message: `Value provided for ${name} is expected to be a non-null and non-empty String/Number.`
		});
	}
	return false;
}
exports.isStringOrNumber = isStringOrNumber;

/**
 * Validates that a value is a proper app instance.
 *
 * @param {any} app The value to validate.
 * @param {Boolean} throwErr Boolean to determine if CatalystAppError needs to be thrown.
 * @return {Boolean} Whether the value is a proper app instance.
 */
function isValidApp(app, throwErr) {
	if (
		!isNonNullObject(app) ||
		!('options' in app) ||
		!('internal' in app) ||
		!isStringOrNumber(app.internal.projectId)
	) {
		if (throwErr) {
			throw new CatalystAppError('INVALID_APP_INSTANCE', 'Project instance is not valid');
		}
		return false;
	}
	return true;
}
exports.isValidApp = isValidApp;

/**
 * Validates that a value is of particular type.
 *
 * @param {any} value The value to validate.
 * @param {any} type The type to be validated with.
 * @param {String} name The name of the value to use in error.
 * @param {Boolean} throwErr Boolean to determine if CatalystAppError needs to be thrown.
 * @return {Boolean} Whether the value is a proper app instance.
 */
function isValidType(value, type, name, throwErr) {
	if (typeof value === type) {
		return true;
	}
	if (throwErr) {
		throw new ValidationError({
			code: 'invalid-argument-type',
			message: `Value provided for ${name} must be of type ${type}`
		});
	}
	return false;
}
exports.isValidType = isValidType;

function wrapValidatorsWithPromise(targetFunction, errorInstance) {
	return new Promise((resolve, reject) => {
		if (typeof targetFunction === 'function') {
			try {
				targetFunction();
			} catch (e) {
				// error is assumed to be a ValidationError Instance
				reject(new errorInstance(e.code, e.message));
			}
		}
		resolve();
	});
}
exports.wrapValidatorsWithPromise = wrapValidatorsWithPromise;
