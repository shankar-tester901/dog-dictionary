'use strict';

const CatalystApiError = require('./error').CatalystApiError;
const querystring = require('querystring');
const http = require('http');
const https = require('https');
const parse = require('url').parse;
const URL = require('url').URL;
const stringify = require('querystring').stringify;
const AUTH_HEADER = require('./constants').AUTH_HEADER;
const PROJECT_KEY_NAME = require('./constants').PROJECT_KEY_NAME;
const CATALYST_ORIGIN = require('./constants').CATALYST_ORIGIN;
const RequestAgent = require('./request-agent').RequestAgent;

class DefaultHttpResponse {
	constructor(resp) {
		this.status = resp.status;
		this.headers = resp.headers;
		this.text = resp.data;
		this.buffer = resp.buffer;
		try {
			this.parsedData = JSON.parse(resp.data);
		} catch (err) {
			this.parsedData = undefined;
			this.parseError = err;
		}
	}
	get data() {
		if (typeof this.parsedData !== 'undefined') {
			return this.parsedData;
		}
		if (this.text === '') {
			throw new CatalystApiError(
				'empty_response',
				'Empty response recevied from server. Raw server ' +
					`response: "${this.text}". Status code: "${this.status}".`
			);
		}
		throw new CatalystApiError(
			'unparsable_response',
			`Error while parsing response data: "${this.parseError.toString()}". Raw server ` +
				`response: "${this.text}". Status code: "${this.status}".`
		);
	}
}

function _finalizeRequest(resolve, reject, response) {
	if (response.status >= 200 && response.status < 300) {
		resolve(response);
	} else {
		reject(
			'Request failed with status ' +
				response.status +
				' and code : ' +
				JSON.parse(response.data).data.error_code +
				' , message : ' +
				JSON.parse(response.data).data.message
		);
	}
}

var _appendQueryData = function(path, data) {
	if (data && Object.keys(data).length > 0) {
		path += path.includes('?') ? '&' : '?';
		path += stringify(data);
	}
	return path;
};

function _request(transport, options, data, config) {
	return new Promise(function(resolve, reject) {
		const req = transport.request(options, (res) => {
			if (req.aborted) {
				return;
			}
			// Uncompress the response body transparently if required.
			let respStream = res;
			const response = {
				status: res.statusCode,
				headers: res.headers,
				request: req,
				data: undefined,
				buffer: undefined,
				config
			};
			const responseBuffer = [];
			respStream.on('data', (chunk) => {
				responseBuffer.push(chunk);
			});
			respStream.on('error', (err) => {
				if (req.aborted) {
					return;
				}
				reject(err, config);
			});
			respStream.on('end', () => {
				const responseData = Buffer.concat(responseBuffer);
				response.data = responseData.toString();
				response.buffer = responseData;
				_finalizeRequest(resolve, reject, response);
			});
		});
		// Handle errors
		req.on('error', (err) => {
			if (req.aborted) {
				return;
			}
			reject(err, config);
		});
		// Send the request
		if (config.type === 'file') {
			config.data.pipe(req);
		} else if (data) {
			req.write(data);
		}
		req.end();
	});
}

function sendRequest(config) {
	let data;
	let headers = Object.assign({}, config.headers);
	if (config.data) {
		if (config.type && config.type == 'skip') {
			data = config.data;
		} else if (config.type && config.type == 'json') {
			data = JSON.stringify(config.data);
			headers['Content-Type'] = 'application/json';
		} else if (config.type && config.type == 'file') {
			data = config.data;
			headers = Object.assign(headers, data.getHeaders());
		} else {
			data = querystring.stringify(config.data);
			headers['Content-Type'] = 'application/x-www-form-urlencoded';
			headers['Content-Length'] = Buffer.byteLength(data);
		}
	}
	if (config.qs) {
		config.path = _appendQueryData(config.path, config.qs);
	}
	let origin = config.origin || CATALYST_ORIGIN;
	config.url = config.url || new URL(config.path, origin).href;
	const parsed = parse(config.url);
	const protocol = parsed.protocol || 'https:';
	const isHttps = protocol === 'https:';
	const transport = isHttps ? https : http;
	const agent = new RequestAgent(protocol, parsed.hostname, false).agent;
	const options = {
		hostname: parsed.hostname,
		port: parsed.port,
		path: parsed.path,
		method: config.method,
		headers,
		agent
	};
	return _request(transport, options, data, config);
}

class HttpClient {
	constructor(app) {
		this.app = app;
	}

	send(config) {
		let requestConf = Object.assign({}, config);
		requestConf.headers = Object.assign({}, config.headers);
		requestConf.headers[PROJECT_KEY_NAME] = this.app.projectKey;
		return sendRequest(requestConf)
			.then((resp) => {
				return new DefaultHttpResponse(resp);
			})
			.catch((err) => {
				throw new CatalystApiError('request_failure', err);
			});
	}
}
exports.HttpClient = HttpClient;

class AuthorizedHttpClient extends HttpClient {
	/**
	 * @param {any} app The app used to fetch access tokens to sign API requests.
	 * @constructor
	 */
	constructor(app) {
		super(app);
		this.app = app;
	}

	send(request) {
		let requestCopy = Object.assign({}, request);
		requestCopy.headers = Object.assign({}, request.headers);
		return this.app.getToken().then((accessTokenObj) => {
			requestCopy.headers[AUTH_HEADER] = accessTokenObj.header;
			return super.send(requestCopy);
		});
	}
}
exports.AuthorizedHttpClient = AuthorizedHttpClient;
